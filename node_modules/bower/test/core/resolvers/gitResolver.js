var expect=require("expect.js");var util=require("util");var path=require("path");var fs=require("graceful-fs");var chmodr=require("chmodr");var rimraf=require("rimraf");var mkdirp=require("mkdirp");var Q=require("q");var mout=require("mout");var Logger=require("bower-logger");var copy=require("../../../lib/util/copy");var GitResolver=require("../../../lib/core/resolvers/GitResolver");var defaultConfig=require("../../../lib/config");describe("GitResolver",function(){var e=path.resolve(__dirname,"../../tmp/tmp");var d=GitResolver.refs;var b;before(function(){b=new Logger()});afterEach(function(){b.removeAllListeners()});function a(){GitResolver.refs=d;GitResolver.clearRuntimeCache()}function c(f){if(typeof f==="string"){f={source:f}}return new GitResolver(f,defaultConfig(),b)}describe("misc",function(){it.skip("should error out if git is not installed");it.skip("should setup git template dir to an empty folder")});describe(".hasNew",function(){before(function(){mkdirp.sync(e)});afterEach(function(f){a();rimraf(path.join(e,".bower.json"),f)});after(function(f){rimraf(e,f)});it("should be true when the resolution type is different",function(f){var g;fs.writeFileSync(path.join(e,".bower.json"),JSON.stringify({name:"foo",version:"0.0.0",_resolution:{type:"version",tag:"0.0.0",commit:"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"}}));GitResolver.refs=function(){return Q.resolve(["bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/heads/master"])};g=c("foo");g.hasNew(e).then(function(h){expect(h).to.be(true);f()}).done()});it("should be true when a higher version for a range is available",function(f){var g;fs.writeFileSync(path.join(e,".bower.json"),JSON.stringify({name:"foo",version:"1.0.0",_resolution:{type:"version",tag:"1.0.0",commit:"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"}}));GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/1.0.0","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/1.0.1"])};g=c("foo");g.hasNew(e).then(function(h){expect(h).to.be(true);f()}).done()});it("should be true when a resolved to a lower version of a range",function(f){var g;fs.writeFileSync(path.join(e,".bower.json"),JSON.stringify({name:"foo",version:"1.0.1",_resolution:{type:"version",tag:"1.0.1",commit:"cccccccccccccccccccccccccccccccccccccccc"}}));GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/1.0.0"])};g=c("foo");g.hasNew(e).then(function(h){expect(h).to.be(true);f()}).done()});it("should be false when resolved to the same tag (with same commit hash) for a given range",function(f){var g;fs.writeFileSync(path.join(e,".bower.json"),JSON.stringify({name:"foo",version:"1.0.1",_resolution:{type:"version",tag:"1.0.1",commit:"cccccccccccccccccccccccccccccccccccccccc"}}));GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/1.0.0","cccccccccccccccccccccccccccccccccccccccc refs/tags/1.0.1"])};g=c("foo");g.hasNew(e).then(function(h){expect(h).to.be(false);f()}).done()});it("should be true when resolved to the same tag (with different commit hash) for a given range",function(f){var g;fs.writeFileSync(path.join(e,".bower.json"),JSON.stringify({name:"foo",version:"1.0.1",_resolution:{type:"version",tag:"1.0.1",commit:"cccccccccccccccccccccccccccccccccccccccc"}}));GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/1.0.0","dddddddddddddddddddddddddddddddddddddddd refs/tags/1.0.1"])};g=c("foo");g.hasNew(e).then(function(h){expect(h).to.be(true);f()}).done()});it("should be true when a different commit hash for a given branch is available",function(f){var g;fs.writeFileSync(path.join(e,".bower.json"),JSON.stringify({name:"foo",_resolution:{type:"branch",branch:"master",commit:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}}));GitResolver.refs=function(){return Q.resolve(["bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/heads/master"])};g=c("foo");g.hasNew(e).then(function(h){expect(h).to.be(true);f()}).done()});it("should be false when resolved to the the same commit hash for a given branch",function(f){var g;fs.writeFileSync(path.join(e,".bower.json"),JSON.stringify({name:"foo",_resolution:{type:"branch",branch:"master",commit:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}}));GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master"])};g=c("foo");g.hasNew(e).then(function(h){expect(h).to.be(false);f()}).done()});it("should be false when targeting commit hashes",function(f){var g;fs.writeFileSync(path.join(e,".bower.json"),JSON.stringify({name:"foo",_resolution:{type:"commit",commit:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}}));GitResolver.refs=function(){return Q.resolve(["bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/heads/master"])};g=c("foo");g.hasNew(e).then(function(h){expect(h).to.be(true);f()}).done()})});describe("._resolve",function(){afterEach(a);it("should call the necessary functions by the correct order",function(f){var g;function h(){GitResolver.apply(this,arguments);this._stack=[]}util.inherits(h,GitResolver);mout.object.mixIn(h,GitResolver);h.prototype.getStack=function(){return this._stack};h.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master"])};h.prototype.resolve=function(){this._stack=[];return GitResolver.prototype.resolve.apply(this,arguments)};h.prototype._findResolution=function(){this._stack.push("before _findResolution");return GitResolver.prototype._findResolution.apply(this,arguments).then(function(i){this._stack.push("after _findResolution");return i}.bind(this))};h.prototype._checkout=function(){this._stack.push("before _checkout");return Q.resolve().then(function(i){this._stack.push("after _checkout");return i}.bind(this))};h.prototype._cleanup=function(){this._stack.push("before _cleanup");return GitResolver.prototype._cleanup.apply(this,arguments).then(function(i){this._stack.push("after _cleanup");return i}.bind(this))};g=new h({source:"foo",target:"master"},defaultConfig(),b);g.resolve().then(function(){expect(g.getStack()).to.eql(["before _findResolution","after _findResolution","before _checkout","after _checkout","before _cleanup","after _cleanup"]);f()}).done()});it("should reject the promise if _checkout is not implemented",function(f){var g=c("foo");GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master"])};g.resolve().then(function(){f(new Error("Should have rejected the promise"))},function(h){expect(h).to.be.an(Error);expect(h.message).to.contain("_checkout not implemented");f()}).done()});it("should reject the promise if #refs is not implemented",function(f){var g=c("foo");g._checkout=function(){return Q.resolve()};g.resolve().then(function(){f(new Error("Should have rejected the promise"))},function(h){expect(h).to.be.an(Error);expect(h.message).to.contain("refs not implemented");f()}).done()})});describe("._findResolution",function(){afterEach(a);it("should resolve to an object",function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master"])};g=c("foo");g._findResolution("*").then(function(h){expect(h).to.be.an("object");f()}).done()});it("should fail to resolve * if no tags/heads are found",function(f){var g;GitResolver.refs=function(){return Q.resolve([])};g=c("foo");g._findResolution("*").then(function(){f(new Error("Should have failed"))},function(h){expect(h).to.be.an(Error);expect(h.message).to.match(/branch master does not exist/i);expect(h.details).to.match(/no branches found/i);expect(h.code).to.equal("ENORESTARGET");f()}).done()});it('should resolve "*" to the latest commit on master if a repository has no valid semver tags',function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/heads/some-branch","cccccccccccccccccccccccccccccccccccccccc refs/tags/some-tag"])};g=c("foo");g._findResolution("*").then(function(h){expect(h).to.eql({type:"branch",branch:"master",commit:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"});f()}).done()});it('should resolve "*" to the latest version if a repository has valid semver tags, ignoring pre-releases',function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/0.1.0","cccccccccccccccccccccccccccccccccccccccc refs/tags/v0.1.1","dddddddddddddddddddddddddddddddddddddddd refs/tags/0.2.0-rc.1"])};g=c("foo");g._findResolution("*").then(function(h){expect(h).to.eql({type:"version",tag:"v0.1.1",commit:"cccccccccccccccccccccccccccccccccccccccc"});f()}).done()});it('should resolve "0.1.*" to the latest version if a repository has valid semver tags, ignoring pre-releases',function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/0.1.0","cccccccccccccccccccccccccccccccccccccccc refs/tags/v0.1.1","dddddddddddddddddddddddddddddddddddddddd refs/tags/0.1.2-rc.1"])};g=c("foo");g._findResolution("0.1.*").then(function(h){expect(h).to.eql({type:"version",tag:"v0.1.1",commit:"cccccccccccccccccccccccccccccccccccccccc"});f()}).done()});it('should resolve "*" to the latest version if a repository has valid semver tags, not ignoring pre-releases if they are the only versions',function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/0.1.0-rc.1","cccccccccccccccccccccccccccccccccccccccc refs/tags/0.1.0-rc.2"])};g=c("foo");g._findResolution("*").then(function(h){expect(h).to.eql({type:"version",tag:"0.1.0-rc.2",commit:"cccccccccccccccccccccccccccccccccccccccc"});f()}).done()});it('should resolve "0.1.*" to the latest version if a repository has valid semver tags, not ignoring pre-releases if they are the only versions',function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/0.1.0-rc.1","cccccccccccccccccccccccccccccccccccccccc refs/tags/0.1.0-rc.2"])};g=c("foo");g._findResolution("0.1.*").then(function(h){expect(h).to.eql({type:"version",tag:"0.1.0-rc.2",commit:"cccccccccccccccccccccccccccccccccccccccc"});f()}).done()});it("should resolve to the latest version that matches a range/version",function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/0.1.0","cccccccccccccccccccccccccccccccccccccccc refs/tags/v0.1.1","eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee refs/tags/0.2.0","ffffffffffffffffffffffffffffffffffffffff refs/tags/v0.2.1"])};g=c("foo");g._findResolution("~0.2.0").then(function(h){expect(h).to.eql({type:"version",tag:"v0.2.1",commit:"ffffffffffffffffffffffffffffffffffffffff"});f()}).done()});it("should resolve to a branch even if target is a range/version that does not exist",function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/heads/3.0.0-wip","cccccccccccccccccccccccccccccccccccccccc refs/tags/v0.1.1"])};g=c("foo");g._findResolution("3.0.0-wip").then(function(h){expect(h).to.eql({type:"branch",branch:"3.0.0-wip",commit:"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"});f()}).done()});it("should resolve to a tag even if target is a range that does not exist",function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/1.0"])};g=c("foo");g._findResolution("1.0").then(function(h){expect(h).to.eql({type:"tag",tag:"1.0",commit:"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"});f()}).done()});it("should resolve to the latest pre-release version that matches a range/version",function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/0.1.0","cccccccccccccccccccccccccccccccccccccccc refs/tags/v0.1.1","eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee refs/tags/0.2.0","ffffffffffffffffffffffffffffffffffffffff refs/tags/v0.2.1-rc.1"])};g=c("foo");g._findResolution("~0.2.1").then(function(h){expect(h).to.eql({type:"version",tag:"v0.2.1-rc.1",commit:"ffffffffffffffffffffffffffffffffffffffff"});f()}).done()});it("should resolve to the exact version if exists",function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/0.8.1","cccccccccccccccccccccccccccccccccccccccc refs/tags/0.8.1+build.1","dddddddddddddddddddddddddddddddddddddddd refs/tags/0.8.1+build.2","eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee refs/tags/0.8.1+build.3"])};g=c("foo");g._findResolution("0.8.1+build.2").then(function(h){expect(h).to.eql({type:"version",tag:"0.8.1+build.2",commit:"dddddddddddddddddddddddddddddddddddddddd"});f()}).done()});it("should fail to resolve if none of the versions matched a range/version",function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/0.1.0","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/v0.1.1"])};g=c("foo");g._findResolution("~0.2.0").then(function(){f(new Error("Should have failed"))},function(h){expect(h).to.be.an(Error);expect(h.message).to.match(/was able to satisfy ~0.2.0/i);expect(h.details).to.match(/available versions: 0\.1\.1, 0\.1\.0/i);expect(h.code).to.equal("ENORESTARGET");f()}).done()});it("should fail to resolve if there are no versions to match a range/version",function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master"])};g=c("foo");g._findResolution("~0.2.0").then(function(){f(new Error("Should have failed"))},function(h){expect(h).to.be.an(Error);expect(h.message).to.match(/was able to satisfy ~0.2.0/i);expect(h.details).to.match(/no versions found in foo/i);expect(h.code).to.equal("ENORESTARGET");f()}).done()});it("should resolve to the specified commit",function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master"])};g=c("foo");g._findResolution("bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb").then(function(h){expect(h).to.eql({type:"commit",commit:"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"});f()}).done()});it("should resolve to the specified short commit",function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master"])};g=c("foo");g._findResolution("bbbbbbb").then(function(h){expect(h).to.eql({type:"commit",commit:"bbbbbbb"});f()}).done()});it("should resolve to the specified tag if it exists",function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/some-tag"])};g=c("foo");g._findResolution("some-tag").then(function(h){expect(h).to.eql({type:"tag",tag:"some-tag",commit:"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"});f()}).done()});it("should resolve to the specified branch if it exists",function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/heads/some-branch"])};g=c("foo");g._findResolution("some-branch").then(function(h){expect(h).to.eql({type:"branch",branch:"some-branch",commit:"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"});f()}).done()});it("should fail to resolve to the specified tag/branch if it doesn't exists",function(f){var g;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/some-tag"])};g=c("foo");g._findResolution("some-branch").then(function(){f(new Error("Should have failed"))},function(h){expect(h).to.be.an(Error);expect(h.message).to.match(/tag\/branch some-branch does not exist/i);expect(h.details).to.match(/available branches: master/i);expect(h.details).to.match(/available tags: some-tag/i);expect(h.code).to.equal("ENORESTARGET");f()}).done()})});describe("._cleanup",function(){beforeEach(function(){mkdirp.sync(e)});afterEach(function(f){a();chmodr(e,511,function(){rimraf(e,f)})});it("should remove the .git folder from the temp dir",function(f){var g=c("foo");var h=path.join(e,".git");this.timeout(30000);copy.copyDir(path.resolve(__dirname,"../../../.git"),h,{mode:511}).then(function(){g._tempDir=e;return g._cleanup().then(function(){expect(fs.existsSync(h)).to.be(false);f()})}).done()});it("should not fail if .git does not exist for some reason",function(f){var g=c("foo");var h=path.join(e,".git");g._tempDir=e;g._cleanup().then(function(){expect(fs.existsSync(h)).to.be(false);f()}).done()});it("should sill run even if _checkout fails for some reason",function(f){var h=c("foo");var g=false;GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master"])};h._tempDir=e;h._checkout=function(){return Q.reject(new Error("Some error"))};h._cleanup=function(){g=true;return GitResolver.prototype._cleanup.apply(this,arguments)};h.resolve().then(function(){f(new Error("Should have failed"))},function(){expect(g).to.be(true);f()}).done()})});describe("._savePkgMeta",function(){before(function(){mkdirp.sync(e)});afterEach(function(f){rimraf(path.join(e,".bower.json"),f)});after(function(f){rimraf(e,f)});it("should save the resolution to the .bower.json to be used later by .hasNew",function(f){var g=c("foo");g._resolution={type:"version",tag:"0.0.1"};g._tempDir=e;g._savePkgMeta({name:"foo",version:"0.0.1"}).then(function(){return Q.nfcall(fs.readFile,path.join(e,".bower.json"))}).then(function(i){var h=JSON.parse(i.toString());expect(h._resolution).to.eql(g._resolution);f()}).done()});it("should save the release in the package meta",function(f){var h=c("foo");var g=path.join(e,".bower.json");h._resolution={type:"version",tag:"0.0.1",commit:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"};h._tempDir=e;h._savePkgMeta({name:"foo",version:"0.0.1"}).then(function(){return Q.nfcall(fs.readFile,g)}).then(function(j){var i=JSON.parse(j.toString());expect(i._release).to.equal("0.0.1")}).then(function(){h._resolution={type:"version",tag:"0.0.1+build.5",commit:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"};return h._savePkgMeta({name:"foo"})}).then(function(){return Q.nfcall(fs.readFile,g)}).then(function(j){var i=JSON.parse(j.toString());expect(i._release).to.equal("0.0.1+build.5")}).then(function(){h._resolution={type:"tag",tag:"0.0.1",commit:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"};return h._savePkgMeta({name:"foo"})}).then(function(){return Q.nfcall(fs.readFile,g)}).then(function(j){var i=JSON.parse(j.toString());expect(i._release).to.equal("0.0.1")}).then(function(){h._resolution={type:"branch",branch:"foo",commit:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"};return h._savePkgMeta({name:"foo"})}).then(function(){return Q.nfcall(fs.readFile,g)}).then(function(j){var i=JSON.parse(j.toString());expect(i._release).to.equal("aaaaaaaaaa")}).then(function(){h._resolution={type:"commit",commit:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"};return h._savePkgMeta({name:"foo"})}).then(function(){return Q.nfcall(fs.readFile,g)}).then(function(j){var i=JSON.parse(j.toString());expect(i._release).to.equal("aaaaaaaaaa");f()}).done()});it("should add the version to the package meta if not present and resolution is a version",function(f){var g=c("foo");g._resolution={type:"version",tag:"v0.0.1"};g._tempDir=e;g._savePkgMeta({name:"foo"}).then(function(){return Q.nfcall(fs.readFile,path.join(e,".bower.json"))}).then(function(i){var h=JSON.parse(i.toString());expect(h.version).to.equal("0.0.1");f()}).done()});it("should remove the version from the package meta if resolution is not a version",function(f){var g=c("foo");g._resolution={type:"commit",commit:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"};g._tempDir=e;g._savePkgMeta({name:"foo",version:"0.0.1"}).then(function(){return Q.nfcall(fs.readFile,path.join(e,".bower.json"))}).then(function(i){var h=JSON.parse(i.toString());expect(h).to.not.have.property("version");f()}).done()});it("should warn if the resolution version is different than the package meta version",function(f){var h=c("foo");var g=false;h._resolution={type:"version",tag:"0.0.1"};h._tempDir=e;b.on("log",function(i){expect(i).to.be.an("object");if(i.level==="warn"&&i.id==="mismatch"){expect(i.message).to.match(/\(0\.0\.0\).*different.*\(0\.0\.1\)/);g=true}});h._savePkgMeta({name:"foo",version:"0.0.0"}).then(function(){return Q.nfcall(fs.readFile,path.join(e,".bower.json"))}).then(function(j){var i=JSON.parse(j.toString());expect(i.version).to.equal("0.0.1");expect(g).to.be(true);f()}).done()});it("should not warn if the resolution version and the package meta version are the same",function(f){var h=c("foo");var g=false;h._resolution={type:"version",tag:"v0.0.1"};h._tempDir=e;h._savePkgMeta({name:"foo",version:"0.0.1"}).then(function(){return Q.nfcall(fs.readFile,path.join(e,".bower.json"))},null).then(function(j){var i=JSON.parse(j.toString());expect(i.version).to.equal("0.0.1");expect(g).to.be(false);f()}).done()})});describe("#branches",function(){afterEach(a);it("should resolve to an empty object if no heads are found",function(f){GitResolver.refs=function(){return Q.resolve([])};GitResolver.branches("foo").then(function(g){expect(g).to.be.an("object");expect(g).to.eql({});f()}).done()});it("should resolve to an object where keys are branches and values their commit hashes",function(f){GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/heads/some-branch","foo refs/heads/invalid","cccccccccccccccccccccccccccccccccccccccc refs/heads/","dddddddddddddddddddddddddddddddddddddddd refs/heads","eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee refs/tags/some-tag","ffffffffffffffffffffffffffffffffffffffff refs/tags/0.1.1"])};GitResolver.branches("foo").then(function(g){expect(g).to.eql({master:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","some-branch":"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"});f()}).done()});it("should cache the result for each source",function(f){GitResolver.refs=function(g){if(g==="foo"){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/heads/some-branch"])}return Q.resolve(["cccccccccccccccccccccccccccccccccccccccc refs/heads/master","dddddddddddddddddddddddddddddddddddddddd refs/heads/other-branch"])};GitResolver.branches("foo").then(function(g){expect(g).to.eql({master:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","some-branch":"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"});return GitResolver.branches("bar")}).then(function(g){expect(g).to.eql({master:"cccccccccccccccccccccccccccccccccccccccc","other-branch":"dddddddddddddddddddddddddddddddddddddddd"});delete GitResolver._cache.branches.get("foo").master;delete GitResolver._cache.branches.get("bar").master;return GitResolver.branches("foo")}).then(function(g){expect(g).to.eql({"some-branch":"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"});return GitResolver.branches("bar")}).then(function(g){expect(g).to.eql({"other-branch":"dddddddddddddddddddddddddddddddddddddddd"});f()}).done()});it("should work if requested in parallel for the same source",function(f){GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/heads/some-branch"])};Q.all([GitResolver.branches("foo"),GitResolver.branches("foo")]).spread(function(h,g){expect(h).to.eql({master:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","some-branch":"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"});expect(h).to.eql(g);f()}).done()})});describe("#tags",function(){afterEach(a);it("should resolve to an empty hash if no tags are found",function(f){GitResolver.refs=function(){return Q.resolve([])};GitResolver.tags("foo").then(function(g){expect(g).to.be.an("object");expect(g).to.eql({});f()}).done()});it("should resolve to an hash of tags",function(f){GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/heads/some-branch","cccccccccccccccccccccccccccccccccccccccc refs/tags/0.2.1","dddddddddddddddddddddddddddddddddddddddd refs/tags/0.1.0","eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee refs/tags/v0.1.1","abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/some-tag","foo refs/tags/invalid","ffffffffffffffffffffffffffffffffffffffff refs/tags/","abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags"])};GitResolver.tags("foo").then(function(g){expect(g).to.eql({"0.2.1":"cccccccccccccccccccccccccccccccccccccccc","0.1.0":"dddddddddddddddddddddddddddddddddddddddd","v0.1.1":"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee","some-tag":"abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"});f()}).done()});it("should cache the result for each source",function(f){GitResolver.refs=function(g){if(g==="foo"){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/tags/0.2.1","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/some-tag"])}return Q.resolve(["cccccccccccccccccccccccccccccccccccccccc refs/tags/0.3.1","dddddddddddddddddddddddddddddddddddddddd refs/tags/some-tag"])};GitResolver.tags("foo").then(function(g){expect(g).to.eql({"0.2.1":"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","some-tag":"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"});return GitResolver.tags("bar")}).then(function(g){expect(g).to.eql({"0.3.1":"cccccccccccccccccccccccccccccccccccccccc","some-tag":"dddddddddddddddddddddddddddddddddddddddd"});delete GitResolver._cache.tags.get("foo")["0.2.1"];delete GitResolver._cache.tags.get("bar")["0.3.1"];return GitResolver.tags("foo")}).then(function(g){expect(g).to.eql({"some-tag":"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"});return GitResolver.tags("bar")}).then(function(g){expect(g).to.eql({"some-tag":"dddddddddddddddddddddddddddddddddddddddd"});f()}).done()});it("should work if requested in parallel for the same source",function(f){GitResolver.refs=function(){return Q.resolve(["cccccccccccccccccccccccccccccccccccccccc refs/tags/0.3.1","dddddddddddddddddddddddddddddddddddddddd refs/tags/some-tag"])};Q.all([GitResolver.tags("foo"),GitResolver.tags("foo")]).spread(function(h,g){expect(h).to.eql({"0.3.1":"cccccccccccccccccccccccccccccccccccccccc","some-tag":"dddddddddddddddddddddddddddddddddddddddd"});expect(g).to.eql(h);f()}).done()})});describe("#clearRuntimeCache",function(){function f(){}util.inherits(f,GitResolver);mout.object.mixIn(f,GitResolver);it("should clear refs cache",function(){f._cache.refs.set("foo",{});f.clearRuntimeCache();expect(f._cache.refs.has("foo")).to.be(false)});it("should clear branches cache",function(){f._cache.branches.set("foo",{});f.clearRuntimeCache();expect(f._cache.branches.has("foo")).to.be(false)});it("should clear tags cache",function(){f._cache.tags.set("foo",{});f.clearRuntimeCache();expect(f._cache.tags.has("foo")).to.be(false)});it("should clear versions cache",function(){f._cache.versions.set("foo",{});f.clearRuntimeCache();expect(f._cache.versions.has("foo")).to.be(false)})});describe("#versions",function(){afterEach(a);it("should resolve to an empty array if no tags are found",function(f){GitResolver.refs=function(){return Q.resolve([])};GitResolver.versions("foo").then(function(g){expect(g).to.be.an("array");expect(g).to.eql([]);f()}).done()});it("should resolve to an empty array if no valid semver tags",function(f){GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/heads/some-branch","cccccccccccccccccccccccccccccccccccccccc refs/tags/some-tag"])};GitResolver.versions("foo").then(function(g){expect(g).to.be.an("array");expect(g).to.eql([]);f()}).done()});it("should resolve to an array of versions, ignoring invalid semver tags",function(f){GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/heads/master","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/heads/some-branch","cccccccccccccccccccccccccccccccccccccccc refs/tags/0.2.1","dddddddddddddddddddddddddddddddddddddddd refs/tags/0.1.0","eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee refs/tags/v0.1.1","foo refs/tags/invalid","ffffffffffffffffffffffffffffffffffffffff refs/tags/","abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags"])};GitResolver.versions("foo",true).then(function(g){expect(g).to.eql([{version:"0.2.1",tag:"0.2.1",commit:"cccccccccccccccccccccccccccccccccccccccc"},{version:"0.1.1",tag:"v0.1.1",commit:"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"},{version:"0.1.0",tag:"0.1.0",commit:"dddddddddddddddddddddddddddddddddddddddd"}])}).then(function(){return GitResolver.versions("foo")}).then(function(g){expect(g).to.eql(["0.2.1","0.1.1","0.1.0"]);f()}).done()});it("should order the versions according to the semver spec",function(f){GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/tags/0.1.0","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/0.1.1+build.11","cccccccccccccccccccccccccccccccccccccccc refs/tags/0.1.1+build.100","dddddddddddddddddddddddddddddddddddddddd refs/tags/0.1.1-rc.22","eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee refs/tags/0.1.1-rc.200","ffffffffffffffffffffffffffffffffffffffff refs/tags/0.1.1","abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/v0.2.1"])};GitResolver.versions("foo",true).then(function(g){expect(g).to.eql([{version:"0.2.1",tag:"v0.2.1",commit:"abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"},{version:"0.1.1+build.11",tag:"0.1.1+build.11",commit:"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"},{version:"0.1.1+build.100",tag:"0.1.1+build.100",commit:"cccccccccccccccccccccccccccccccccccccccc"},{version:"0.1.1",tag:"0.1.1",commit:"ffffffffffffffffffffffffffffffffffffffff"},{version:"0.1.1-rc.200",tag:"0.1.1-rc.200",commit:"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"},{version:"0.1.1-rc.22",tag:"0.1.1-rc.22",commit:"dddddddddddddddddddddddddddddddddddddddd"},{version:"0.1.0",tag:"0.1.0",commit:"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}]);f()}).done()});it("should cache the result for each source",function(f){GitResolver.refs=function(g){if(g==="foo"){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/tags/0.2.1","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/0.1.0"])}return Q.resolve(["cccccccccccccccccccccccccccccccccccccccc refs/tags/0.3.1","dddddddddddddddddddddddddddddddddddddddd refs/tags/0.3.0"])};GitResolver.versions("foo").then(function(g){expect(g).to.eql(["0.2.1","0.1.0"]);return GitResolver.versions("bar")}).then(function(g){expect(g).to.eql(["0.3.1","0.3.0"]);GitResolver._cache.versions.get("foo").splice(1,1);GitResolver._cache.versions.get("bar").splice(1,1);return GitResolver.versions("foo")}).then(function(g){expect(g).to.eql(["0.2.1"]);return GitResolver.versions("bar")}).then(function(g){expect(g).to.eql(["0.3.1"]);f()}).done()});it("should work if requested in parallel for the same source",function(f){GitResolver.refs=function(){return Q.resolve(["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa refs/tags/0.2.1","bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb refs/tags/0.1.0"])};Q.all([GitResolver.versions("foo"),GitResolver.versions("foo")]).spread(function(h,g){expect(h).to.eql(["0.2.1","0.1.0"]);expect(g).to.eql(h);f()}).done()})})});