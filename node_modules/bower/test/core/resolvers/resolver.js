var expect=require("expect.js");var fs=require("graceful-fs");var path=require("path");var util=require("util");var rimraf=require("rimraf");var mkdirp=require("mkdirp");var tmp=require("tmp");var Q=require("q");var Logger=require("bower-logger");var cmd=require("../../../lib/util/cmd");var copy=require("../../../lib/util/copy");var Resolver=require("../../../lib/core/resolvers/Resolver");var defaultConfig=require("../../../lib/config");describe("Resolver",function(){var e=path.resolve(__dirname,"../../tmp/tmp");var d=path.resolve(__dirname,"../../assets/package-a");var b;var f;var a=defaultConfig();before(function(){var g;mkdirp.sync(e);g=fs.statSync(e);f=g.mode;rimraf.sync(e);b=new Logger()});afterEach(function(){b.removeAllListeners()});function c(g){if(typeof g==="string"){g={source:g}}return new Resolver(g,a,b)}describe(".getSource",function(){it("should return the resolver source",function(){var g=c("foo");expect(g.getSource()).to.equal("foo")})});describe(".getName",function(){it("should return the resolver name",function(){var g=c({source:"foo",name:"bar"});expect(g.getName()).to.equal("bar")});it("should return the resolver source if none is specified (default guess mechanism)",function(){var g=c("foo");expect(g.getName()).to.equal("foo")})});describe(".getTarget",function(){it("should return the resolver target",function(){var g=c({source:"foo",target:"~2.1.0"});expect(g.getTarget()).to.equal("~2.1.0")});it("should return * if none was configured",function(){var g=c("foo");expect(g.getTarget()).to.equal("*")});it("should return * if latest was configured (for backwards compatibility)",function(){var g=c("foo");expect(g.getTarget()).to.equal("*")})});describe(".hasNew",function(){before(function(){mkdirp.sync(e)});beforeEach(function(){fs.writeFileSync(path.join(e,".bower.json"),JSON.stringify({name:"test"}))});after(function(g){rimraf(e,g)});it("should throw an error if already working (resolving)",function(g){var i=c("foo");var h;i._resolve=function(){};i.resolve().then(function(){i.resolve().then(function(){g(h?new Error("Should have failed"):null)})}).done();i.hasNew(e).then(function(){h=true},function(j){expect(j).to.be.an(Error);expect(j.code).to.equal("EWORKING");expect(j.message).to.match(/already working/i)})});it("should throw an error if already working (checking for newer version)",function(g){var i=c("foo");var h;i.hasNew(e).then(function(){i.hasNew(e).then(function(){g(h?new Error("Should have failed"):null)})}).done();i.hasNew(e).then(function(){h=true},function(j){expect(j).to.be.an(Error);expect(j.code).to.equal("EWORKING");expect(j.message).to.match(/already working/i)})});it("should resolve to true by default",function(g){var h=c("foo");h.hasNew(e).then(function(i){expect(i).to.equal(true);g()}).done()});it("should resolve to true if the there's an error reading the package meta",function(g){var h=c("foo");rimraf.sync(path.join(e,".bower.json"));h.hasNew(e).then(function(i){expect(i).to.equal(true);g()}).done()});it("should call _hasNew with the canonical dir and the package meta",function(h){var j=c("foo");var g;var i;j._hasNew=function(k,l){g=k;i=l;return Q.resolve(true)};j.hasNew(e).then(function(){expect(g).to.equal(e);expect(i).to.be.an("object");expect(i.name).to.equal("test");h()}).done()});it("should not read the package meta if already passed",function(g){var i=c("foo");var h;i._hasNew=function(j,k){h=k;return Q.resolve(true)};i.hasNew(e,{name:"foo"}).then(function(){expect(h).to.be.an("object");expect(h.name).to.equal("foo");g()}).done()})});describe(".resolve",function(){it("should reject the promise if _resolve is not implemented",function(g){var h=c("foo");h.resolve().then(function(){g(new Error("Should have rejected the promise"))},function(i){expect(i).to.be.an(Error);expect(i.message).to.contain("_resolve not implemented");g()}).done()});it("should throw an error if already working (resolving)",function(g){var i=c("foo");var h;i._resolve=function(){};i.resolve().then(function(){i.resolve().then(function(){g(h?new Error("Should have failed"):null)})}).done();i.resolve().then(function(){h=true},function(j){expect(j).to.be.an(Error);expect(j.code).to.equal("EWORKING");expect(j.message).to.match(/already working/i)})});it("should throw an error if already working (checking newer version)",function(g){var i=c("foo");var h;i._resolve=function(){};i.hasNew(e).then(function(){i.hasNew(e).then(function(){g(h?new Error("Should have failed"):null)})}).done();i.resolve().then(function(){h=true},function(j){expect(j).to.be.an(Error);expect(j.code).to.equal("EWORKING");expect(j.message).to.match(/already working/i)})});it("should call all the functions necessary to resolve by the correct order",function(g){var h;function i(){Resolver.apply(this,arguments);this._stack=[]}util.inherits(i,Resolver);i.prototype.getStack=function(){return this._stack};i.prototype.resolve=function(){this._stack=[];return Resolver.prototype.resolve.apply(this,arguments)};i.prototype._createTempDir=function(){this._stack.push("before _createTempDir");return Resolver.prototype._createTempDir.apply(this,arguments).then(function(j){this._stack.push("after _createTempDir");return j}.bind(this))};i.prototype._resolve=function(){};i.prototype._readJson=function(){this._stack.push("before _readJson");return Resolver.prototype._readJson.apply(this,arguments).then(function(j){this._stack.push("after _readJson");return j}.bind(this))};i.prototype._applyPkgMeta=function(){this._stack.push("before _applyPkgMeta");return Resolver.prototype._applyPkgMeta.apply(this,arguments).then(function(j){this._stack.push("after _applyPkgMeta");return j}.bind(this))};i.prototype._savePkgMeta=function(){this._stack.push("before _savePkgMeta");return Resolver.prototype._savePkgMeta.apply(this,arguments).then(function(j){this._stack.push("after _savePkgMeta");return j}.bind(this))};h=new i({source:"foo"},a,b);h.resolve().then(function(){expect(h.getStack()).to.eql(["before _createTempDir","after _createTempDir","before _readJson","after _readJson","before _applyPkgMeta","after _applyPkgMeta","before _savePkgMeta","after _savePkgMeta"]);g()}).done()});it("should resolve with the canonical dir (folder)",function(g){var h=c("foo");h._resolve=function(){};h.resolve().then(function(i){expect(i).to.be.a("string");expect(fs.existsSync(i)).to.be(true);g()}).done()})});describe(".getTempDir",function(){it("should return null if resolver is not yet resolved",function(){var g=c("foo");expect(g.getTempDir()==null).to.be(true)});it("should still return null if resolve failed",function(){it("should still return null",function(g){var h=c("foo");h._resolve=function(){throw new Error("I've failed to resolve")};h.resolve().fail(function(){expect(h.getTempDir()==null).to.be(true);g()})})});it("should return the canonical dir (folder) if resolve succeeded",function(g){var h=c("foo");h._resolve=function(){};h.resolve().then(function(){var i=h.getTempDir();expect(i).to.be.a("string");expect(fs.existsSync(i)).to.be(true);g()}).done()})});describe(".getPkgMeta",function(){it("should return null if resolver is not yet resolved",function(){var g=c("foo");expect(g.getPkgMeta()==null).to.be(true)});it("should still return null if resolve failed",function(){it("should still return null",function(g){var h=c("foo");h._resolve=function(){throw new Error("I've failed to resolve")};h.resolve().fail(function(){expect(h.getPkgMeta()==null).to.be(true);g()})})});it("should return the package meta if resolve succeeded",function(g){var h=c("foo");h._resolve=function(){};h.resolve().then(function(){expect(h.getPkgMeta()).to.be.an("object");g()}).done()})});describe("._createTempDir",function(){it('should create a directory inside a "username/bower" folder, located within the OS temp folder',function(g){var h=c("foo");h._createTempDir().then(function(i){var k;var j;expect(i).to.be.a("string");expect(fs.existsSync(i)).to.be(true);k=path.dirname(i);j=path.resolve(tmp.tmpdir);expect(i.indexOf(j)).to.be(0);expect(i.indexOf(a.tmp)).to.be(0);expect(path.basename(k)).to.equal("bower");expect(path.dirname(path.dirname(k))).to.equal(j);g()}).done()});it("should set the dir mode the same as the process",function(g){var h=c("foo");h._createTempDir().then(function(i){var j=fs.statSync(i);var k=f&~process.umask();expect(j.mode).to.equal(k);g()}).done()});it("should remove the folder after execution",function(g){this.timeout(15000);rimraf(a.tmp,function(h){if(h){return g(h)}cmd("node",["test/assets/test-temp-dir/test.js"],{cwd:path.resolve(__dirname,"../../..")}).then(function(){expect(fs.existsSync(a.tmp)).to.be(true);expect(fs.readdirSync(a.tmp)).to.eql([]);g()},function(i){g(new Error(i.details))}).done()})});it("should remove the folder on an uncaught exception",function(g){rimraf(a.tmp,function(h){if(h){return g(h)}cmd("node",["test/assets/test-temp-dir/test-exception.js"],{cwd:path.resolve(__dirname,"../../..")}).then(function(){g(new Error("The command should have failed"))},function(){expect(fs.existsSync(a.tmp)).to.be(true);expect(fs.readdirSync(a.tmp)).to.eql([]);g()}).done()})});it("should set _tempDir with the created directory",function(g){var h=c("foo");h._createTempDir().then(function(i){expect(h._tempDir).to.be.ok();expect(h._tempDir).to.equal(i);g()}).done()})});describe("._cleanTempDir",function(){it("should not error out if temporary dir is not yet created",function(g){var h=c("foo");h._cleanTempDir().then(g.bind(null)).done()});it("should delete the temporary folder contents",function(g){var h=c("foo");h._createTempDir().then(h._cleanTempDir.bind(h)).then(function(i){expect(i).to.equal(h.getTempDir());expect(fs.readdirSync(i).length).to.be(0);g()}).done()});it("should keep the mode",function(g){var h=c("foo");h._createTempDir().then(h._cleanTempDir.bind(h)).then(function(i){var j=fs.statSync(i);var k=f&~process.umask();expect(j.mode).to.equal(k);g()}).done()});it("should keep the dir path",function(g){var i=c("foo");var h;i._createTempDir().then(function(j){h=j;return i._cleanTempDir()}).then(function(j){expect(j).to.equal(h);g()}).done()})});describe("._readJson",function(){afterEach(function(g){rimraf(e,g)});it("should read the bower.json file",function(g){var h=c("foo");mkdirp.sync(e);fs.writeFileSync(path.join(e,"bower.json"),JSON.stringify({name:"foo",version:"0.0.0"}));fs.writeFileSync(path.join(e,"component.json"),JSON.stringify({name:"bar",version:"0.0.0"}));h._readJson(e).then(function(i){expect(i).to.be.an("object");expect(i.name).to.equal("foo");expect(i.version).to.equal("0.0.0");g()}).done()});it("should fallback to component.json (notifying a warn)",function(g){var i=c("foo");var h=false;mkdirp.sync(e);fs.writeFileSync(path.join(e,"component.json"),JSON.stringify({name:"bar",version:"0.0.0"}));b.on("log",function(j){expect(j).to.be.an("object");if(j.level==="warn"&&/deprecated/i.test(j.id)){expect(j.message).to.contain("component.json");h=true}});i._readJson(e).then(function(j){expect(j).to.be.an("object");expect(j.name).to.equal("bar");expect(j.version).to.equal("0.0.0");expect(h).to.be(true);g()}).done()});it("should resolve to an inferred json if no json file was found",function(g){var h=c("foo");h._readJson(e).then(function(i){expect(i).to.be.an("object");expect(i.name).to.equal("foo");g()}).done()});it.skip("should apply normalisation, defaults and validation to the json object")});describe("._applyPkgMeta",function(){afterEach(function(g){rimraf(e,g)});it("should resolve with the same package meta",function(g){var i=c("foo");var h={name:"foo"};mkdirp.sync(e);i._tempDir=e;i._applyPkgMeta(h).then(function(j){expect(j).to.equal(h);h={name:"foo",ignore:["somefile"]};return i._applyPkgMeta(h).then(function(k){expect(k).to.equal(h);g()})}).done()});it("should remove files that match the ignore patterns excluding main files",function(g){var h=c({source:"foo",name:"foo"});mkdirp.sync(e);cmd("git",["checkout","0.2.2"],{cwd:d}).then(function(){return copy.copyDir(d,e)}).then(function(){var i;h._tempDir=e;i=JSON.parse(fs.readFileSync(path.join(e,"bower.json")).toString());return h._applyPkgMeta(i).then(function(){expect(fs.existsSync(path.join(e,"foo"))).to.be(true);expect(fs.existsSync(path.join(e,"baz"))).to.be(true);expect(fs.existsSync(path.join(e,"test"))).to.be(false);expect(fs.existsSync(path.join(e,"bower.json"))).to.be(true);expect(fs.existsSync(path.join(e,"main.js"))).to.be(true);expect(fs.existsSync(path.join(e,"more/docs"))).to.be(false);expect(fs.existsSync(path.join(e,"more/assets"))).to.be(false);g()})}).done()});describe("handling of ignore property according to the .gitignore spec",function(){it.skip("A blank line matches no files, so it can serve as a separator for readability.");it.skip("A line starting with # serves as a comment.");it.skip("An optional prefix ! which negates the pattern; any matching file excluded by a previous pattern will become included again...",function(){});it.skip("If the pattern ends with a slash, it is removed for the purpose of the following description, but it would only find a match with a directory...",function(){});it.skip("If the pattern does not contain a slash /, git treats it as a shell glob pattern and checks for a match against the pathname without leading directories.");it.skip("Otherwise, git treats the pattern as a shell glob suitable for consumption by fnmatch(3) with the FNM_PATHNAME flag..",function(){})})});describe("._savePkgMeta",function(){before(function(){mkdirp.sync(e)});afterEach(function(g){rimraf(path.join(e,".bower.json"),g)});after(function(g){rimraf(e,g)});it("should resolve with the same package meta",function(g){var i=c("foo");var h={name:"foo"};i._tempDir=e;i._savePkgMeta(h).then(function(j){expect(j).to.equal(h);g()}).done()});it("should set the original source and target in package meta file",function(g){var i=c({source:"bar",target:"~2.0.0"});var h={name:"foo"};i._tempDir=e;i._savePkgMeta(h).then(function(j){expect(j._source).to.equal("bar");expect(j._target).to.equal("~2.0.0");g()}).done()});it("should save the package meta to the package meta file (.bower.json)",function(g){var h=c("foo");h._tempDir=e;h._savePkgMeta({name:"bar"}).then(function(i){fs.readFile(path.join(e,".bower.json"),function(k,j){if(k){return g(k)}j=j.toString();expect(JSON.parse(j)).to.eql(i);g()})}).done()});it("should warn user for missing attributes in bower.json",function(g){var h=c("fooooo");h._tempDir=e;var i=0;b.on("log",function(j){i++;expect(j).to.be.an("object");expect(j.level).to.be("warn");if(i===1){expect(j.message).to.contain('bar is missing "main" entry in bower.json')}else{expect(j.message).to.contain('bar is missing "ignore" entry in bower.json')}});h._savePkgMeta({name:"bar"});expect(i).to.be(2);h._savePkgMeta({name:"bar",main:"foo"});expect(i).to.be(3);h._savePkgMeta({name:"bar",main:"flart",ignore:"blat"});expect(i).to.be(3);g()})});describe("#isTargetable",function(){it("should return true by default",function(){expect(Resolver.isTargetable()).to.be(true)})});describe("#versions",function(){it("should resolve to an array by default",function(g){Resolver.versions().then(function(h){expect(h).to.be.an("array");expect(h.length).to.be(0);g()}).done()})});describe("#isCacheable",function(){it("caches for normal name",function(){var g=new Resolver({source:"foo"});expect(g.isCacheable()).to.be(true)});it("does not cache for absolute paths",function(){var g=new Resolver({source:"/foo"});expect(g.isCacheable()).to.be(false)});it("does not cache for relative paths",function(){var g=new Resolver({source:"./foo"});expect(g.isCacheable()).to.be(false)});it("does not cache for parent paths",function(){var g=new Resolver({source:"../foo"});expect(g.isCacheable()).to.be(false)});it("does not cache for file:/// prefix",function(){var g=new Resolver({source:"file:///foo"});expect(g.isCacheable()).to.be(false)});it("does not cache for windows paths",function(){var g=new Resolver({source:"..\\foo"});expect(g.isCacheable()).to.be(false)});it("does not cache for windows absolute paths",function(){var g=new Resolver({source:"C:\\foo"});expect(g.isCacheable()).to.be(false)})})});