var expect=require("expect.js");var Q=require("q");var path=require("path");var mout=require("mout");var fs=require("graceful-fs");var rimraf=require("rimraf");var RegistryClient=require("bower-registry-client");var Logger=require("bower-logger");var proxyquire=require("proxyquire");var defaultConfig=require("../../lib/config");var ResolveCache=require("../../lib/core/ResolveCache");var resolvers=require("../../lib/core/resolvers");var copy=require("../../lib/util/copy");describe("PackageRepository",function(){var b;var d;var h;var j;var f=path.resolve(__dirname,"../assets/package-a");var g=path.resolve(__dirname,"../tmp/temp-package");var i=path.join(__dirname,"../tmp/temp-resolve-cache");var a=path.join(__dirname,"../tmp/temp-registry-cache");var e="file://"+f;var c=true;after(function(){rimraf.sync(a);rimraf.sync(i)});beforeEach(function(n){var o;var l;var k=new Logger();l=defaultConfig({storage:{packages:i,registry:a}});function m(q,s,r,p){expect(s).to.eql(l);expect(r).to.be.an(Logger);expect(p).to.be.an(RegistryClient);q=mout.object.deepMixIn({},q);q.source=e;d=new resolvers.GitRemote(q,s,r);if(c){d.isCacheable=function(){return true}}h(d);return Q.resolve(d)}m.getConstructor=function(){return Q.resolve([resolvers.GitRemote,"file://"+f,false])};m.clearRuntimeCache=function(){j()};o=proxyquire("../../lib/core/PackageRepository",{"./resolverFactory":m});b=new o(l,k);h=j=function(){};rimraf.sync(g);b.clear().then(n.bind(n,null),n)});describe(".constructor",function(){it("should pass the config correctly to the registry client, including its cache folder",function(){expect(b._registryClient._config.cache).to.equal(a)})});describe(".fetch",function(){it("should call the resolver factory to get the appropriate resolver",function(k){var l;h=function(){l=true};b.fetch({name:"",source:"foo",target:"~0.1.0"}).spread(function(m,n){expect(l).to.be(true);expect(fs.existsSync(m)).to.be(true);expect(n).to.be.an("object");expect(n.name).to.be("package-a");expect(n.version).to.be("0.1.1");k()}).done()});it("should just call the resolver resolve method if force was specified",function(k){var l=[];h=function(n){var m=n.resolve;n.resolve=function(){l.push("resolve");return m.apply(this,arguments)};n.hasNew=function(){l.push("hasNew");return Q.resolve(false)}};b._resolveCache.retrieve=function(){l.push("retrieve");return Q.resolve([])};b._config.force=true;b.fetch({name:"",source:"foo",target:" ~0.1.0"}).spread(function(m,n){expect(l).to.eql(["resolve"]);expect(fs.existsSync(m)).to.be(true);expect(n).to.be.an("object");expect(n.name).to.be("package-a");expect(n.version).to.be("0.1.1");k()}).done()});it("should attempt to retrieve a resolved package from the resolve package",function(l){var m=false;var k=b._resolveCache.retrieve;b._resolveCache.retrieve=function(n){m=true;expect(n).to.be(e);return k.apply(this,arguments)};b.fetch({name:"",source:"foo",target:"~0.1.0"}).spread(function(n,o){expect(m).to.be(true);expect(fs.existsSync(n)).to.be(true);expect(o).to.be.an("object");expect(o.name).to.be("package-a");expect(o.version).to.be("0.1.1");l()}).done()});it("should avoid using cache for local resources",function(l){c=false;var m=false;var k=b._resolveCache.retrieve;b._resolveCache.retrieve=function(n){m=true;expect(n).to.be(e);return k.apply(this,arguments)};b.fetch({name:"",source:f,target:"~0.1.0"}).spread(function(n,o){expect(m).to.be(false);expect(fs.existsSync(n)).to.be(true);expect(o).to.be.an("object");expect(o.name).to.be("package-a");expect(o.version).to.be("0.1.1");c=true;l()}).done()});it("should just call the resolver resolve method if no appropriate package was found in the resolve cache",function(k){var l=[];h=function(n){var m=n.resolve;n.resolve=function(){l.push("resolve");return m.apply(this,arguments)};n.hasNew=function(){l.push("hasNew")}};b._resolveCache.retrieve=function(){return Q.resolve([])};b.fetch({name:"",source:"foo",target:" ~0.1.0"}).spread(function(m,n){expect(l).to.eql(["resolve"]);expect(fs.existsSync(m)).to.be(true);expect(n).to.be.an("object");expect(n.name).to.be("package-a");expect(n.version).to.be("0.1.1");k()}).done()});it("should call the resolver hasNew method if an appropriate package was found in the resolve cache",function(l){var k={name:"a",version:"0.2.1"};var m;h=function(o){var n=o.hasNew;o.hasNew=function(p,q){expect(p).to.equal(g);expect(q).to.eql(k);m=true;return n.apply(this,arguments)}};b._resolveCache.retrieve=function(){return Q.resolve([g,k])};copy.copyDir(f,g,{ignore:[".git"]}).then(function(){fs.writeFileSync(path.join(g,".bower.json"),JSON.stringify(k));return b.fetch({name:"",source:"foo",target:"~0.1.0"}).spread(function(n,o){expect(m).to.be(true);expect(fs.existsSync(n)).to.be(true);expect(o).to.be.an("object");expect(o.name).to.be("package-a");expect(o.version).to.be("0.1.1");l()})}).done()});it("should call the resolver resolve method if hasNew resolved to true",function(l){var k={name:"a",version:"0.2.0"};var m=[];h=function(o){var n=o.resolve;o.resolve=function(){m.push("resolve");return n.apply(this,arguments)};o.hasNew=function(p,q){expect(p).to.equal(g);expect(q).to.eql(k);m.push("hasNew");return Q.resolve(true)}};b._resolveCache.retrieve=function(){return Q.resolve([g,k])};copy.copyDir(f,g,{ignore:[".git"]}).then(function(){fs.writeFileSync(path.join(g,".bower.json"),JSON.stringify(k));return b.fetch({name:"",source:"foo",target:"~0.2.0"}).spread(function(n,o){expect(m).to.eql(["hasNew","resolve"]);expect(fs.existsSync(n)).to.be(true);expect(o).to.be.an("object");expect(o.name).to.be("a");expect(o.version).to.be("0.2.2");l()})}).done()});it("should resolve to the cached package if hasNew resolve to false",function(l){var k={name:"a",version:"0.2.0"};var m=[];h=function(o){var n=o.resolve;o.resolve=function(){m.push("resolve");return n.apply(this,arguments)};o.hasNew=function(p,q){expect(p).to.equal(g);expect(q).to.eql(k);m.push("hasNew");return Q.resolve(false)}};b._resolveCache.retrieve=function(){return Q.resolve([g,k])};copy.copyDir(f,g,{ignore:[".git"]}).then(function(){fs.writeFileSync(path.join(g,".bower.json"),JSON.stringify(k));return b.fetch({name:"",source:"foo",target:"~0.2.0"}).spread(function(n,o){expect(m).to.eql(["hasNew"]);expect(n).to.equal(g);expect(o).to.eql(k);l()})}).done()});it("should just use the cached package if offline was specified",function(l){var k={name:"a",version:"0.2.0"};var m=[];h=function(o){var n=o.resolve;o.hasNew=function(p,q){expect(p).to.equal(g);expect(q).to.eql(k);m.push("resolve");return n.apply(this,arguments)};o.hasNew=function(){m.push("hasNew");return Q.resolve(false)}};b._resolveCache.retrieve=function(){return Q.resolve([g,k])};copy.copyDir(f,g,{ignore:[".git"]}).then(function(){fs.writeFileSync(path.join(g,".bower.json"),JSON.stringify(k));b._config.offline=true;return b.fetch({name:"",source:"foo",target:"~0.2.0"}).spread(function(n,o){expect(m.length).to.be(0);expect(n).to.equal(g);expect(o).to.eql(k);l()})}).done()});it("should error out if there is no appropriate package in the resolve cache and offline was specified",function(k){b._config.offline=true;b.fetch({name:"",source:"foo",target:"~0.2.0"}).then(function(){throw new Error("Should have failed")},function(l){expect(l).to.be.an(Error);expect(l.code).to.equal("ENOCACHE");k()}).done()})});describe(".versions",function(){it("should call the versions method on the concrete resolver",function(l){var m=[];var k=resolvers.GitRemote.versions;resolvers.GitRemote.versions=function(n){expect(n).to.equal(e);m.push("resolver");return Q.resolve([])};b._resolveCache.versions=function(){m.push("resolve-cache");return Q.resolve([])};b.versions("foo").then(function(n){expect(m).to.eql(["resolver"]);expect(n).to.be.an("array");expect(n.length).to.be(0);l()}).fin(function(){resolvers.GitRemote.versions=k}).done()});it("should call the versions method on the resolve cache if offline was specified",function(l){var m=[];var k=resolvers.GitRemote.versions;resolvers.GitRemote.versions=function(){m.push("resolver");return Q.resolve([])};b._resolveCache.versions=function(n){expect(n).to.equal(e);m.push("resolve-cache");return Q.resolve([])};b._config.offline=true;b.versions("foo").then(function(n){expect(m).to.eql(["resolve-cache"]);expect(n).to.be.an("array");expect(n.length).to.be(0);l()}).fin(function(){resolvers.GitRemote.versions=k}).done()})});describe(".eliminate",function(){it("should call the eliminate method from the resolve cache",function(l){var m;var k={name:"a",version:"0.2.0",_source:"foo"};b._resolveCache.eliminate=function(n){expect(n).to.eql(k);m=true;return Q.resolve()};b.eliminate(k).then(function(){expect(m).to.be(true);l()}).done()});it("should call the clearCache method with the name from the registry client",function(l){var m;var k={name:"a",version:"0.2.0",_source:"foo"};b._registryClient.clearCache=function(n,o){expect(n).to.eql(k.name);m=true;o()};b.eliminate(k).then(function(){expect(m).to.be(true);l()}).done()})});describe(".list",function(){it("should proxy to the resolve cache list method",function(k){var l;var m=b._resolveCache.list;b._resolveCache.list=function(){l=true;return m.apply(this,arguments)};b.list().then(function(n){expect(l).to.be(true);expect(n).to.be.an("array");k()}).done()})});describe(".clear",function(){it("should call the clear method from the resolve cache",function(k){var l;b._resolveCache.clear=function(){l=true;return Q.resolve()};b.clear().then(function(){expect(l).to.be(true);k()}).done()});it("should call the clearCache method without name from the registry client",function(k){var l;b._registryClient.clearCache=function(m){l=true;m()};b.clear().then(function(){expect(l).to.be(true);k()}).done()})});describe(".reset",function(){it("should call the reset method from the resolve cache",function(){var k;b._resolveCache.reset=function(){k=true;return b._resolveCache};b.reset();expect(k).to.be(true)});it("should call the resetCache method without name from the registry client",function(){var k;b._registryClient.resetCache=function(){k=true;return b._registryClient};b.reset();expect(k).to.be(true)})});describe(".getRegistryClient",function(){it("should return the underlying registry client",function(){expect(b.getRegistryClient()).to.be.an(RegistryClient)})});describe(".getResolveCache",function(){it("should return the underlying resolve cache",function(){expect(b.getResolveCache()).to.be.an(ResolveCache)})});describe("#clearRuntimeCache",function(){it("should clear the resolve cache runtime cache",function(){var k;var l=ResolveCache.clearRuntimeCache;ResolveCache.clearRuntimeCache=function(){k=true;return l.apply(ResolveCache,arguments)};b.constructor.clearRuntimeCache();expect(k).to.be(true)});it("should clear the resolver factory runtime cache",function(){var k;j=function(){k=true};b.constructor.clearRuntimeCache();expect(k).to.be(true)});it("should clear the registry runtime cache",function(){var k;var l=RegistryClient.clearRuntimeCache;RegistryClient.clearRuntimeCache=function(){k=true;return l.apply(RegistryClient,arguments)};b.constructor.clearRuntimeCache();expect(k).to.be(true)})})});