"use strict";var expect=require("expect.js");var Q=require("q");var PThtroller=require("../");describe("PThtroller",function(){var a;afterEach(function(){if(a){clearTimeout(a);a=null}});describe(".enqueue",function(){it("return a promise",function(){var c=new PThtroller();var b;b=c.enqueue(function(){return Q.resolve("foo")});expect(b).to.be.an("object");expect(b.then).to.be.a("function")});it("should call the function and fulfill the promise accordingly",function(b){var c=new PThtroller();c.enqueue(function(){return Q.resolve("foo")}).then(function(d){expect(d).to.equal("foo");return c.enqueue(function(){return Q.reject(new Error("foo"))})}).fail(function(d){expect(d).to.be.an(Error);expect(d.message).to.equal("foo");b()}).done()});it("should forward promise progress",function(){var b;var c=new PThtroller();c.enqueue(function(){var d=Q.defer();setImmediate(function(){d.notify(0.5);d.resolve("foo")});return d.promise}).progress(function(d){b=d}).then(function(d){expect(d).to.equal("foo");expect(b).to.equal(0.5)}).done()});it("should work with functions that return values syncronously",function(b){var c=new PThtroller();c.enqueue(function(){return"foo"}).then(function(d){expect(d).to.equal("foo");b()}).done()});it("should assume the default concurrency when a type is not specified",function(c){var d=new PThtroller(1);var b=0;d.enqueue(function(){b++;return Q.defer().promise});d.enqueue(function(){c(new Error("Should not be called!"))});a=setTimeout(function(){expect(b).to.equal(1);c()},25)});it("should assume the default concurrency when a type is not known",function(c){var d=new PThtroller(1);var b=0;d.enqueue(function(){b++;return Q.defer().promise},"foo_type");d.enqueue(function(){c(new Error("Should not be called!"))},"foo_type");a=setTimeout(function(){expect(b).to.equal(1);c()},25)});it("should have different slots when type is not passed or is not known",function(c){var d=new PThtroller(1);var b=0;d.enqueue(function(){b++;return Q.defer().promise});d.enqueue(function(){b++;return Q.defer().promise},"foo_type");d.enqueue(function(){c(new Error("Should not be called!"))});d.enqueue(function(){c(new Error("Should not be called!"))},"foo_type");a=setTimeout(function(){expect(b).to.equal(2);c()},25)});it("should use the configured concurrency for the type",function(c){var d=new PThtroller(1,{foo:2,bar:3});var b={def:0,foo:0,bar:0};d.enqueue(function(){b.def++;return Q.defer().promise});d.enqueue(function(){c(new Error("Should not be called!"))});d.enqueue(function(){b.foo++;return Q.defer().promise},"foo");d.enqueue(function(){b.foo++;return Q.defer().promise},"foo");d.enqueue(function(){b.bar++;return Q.defer().promise},"bar");d.enqueue(function(){b.bar++;return Q.defer().promise},"bar");d.enqueue(function(){b.bar++;return Q.defer().promise},"bar");d.enqueue(function(){c(new Error("Should not be called!"))},"bar");a=setTimeout(function(){expect(b.def).to.equal(1);expect(b.foo).to.equal(2);expect(b.bar).to.equal(3);c()},25)})});describe(".abort",function(){it("should clear the whole queue",function(c){var d=new PThtroller(1,{foo:2});var b=0;d.enqueue(function(){b++;return Q.resolve()});d.enqueue(function(){c(new Error("Should not be called!"))});d.enqueue(function(){b++;return Q.resolve()},"foo");d.enqueue(function(){b++;return Q.resolve()},"foo");d.enqueue(function(){c(new Error("Should not be called!"))},"foo");d.abort();d.enqueue(function(){b++;return Q.resolve()},"foo");a=setTimeout(function(){expect(b).to.equal(4);c()},25)});it("should wait for currently running functions to finish",function(c){var d=new PThtroller(1,{foo:2});var b=[];d.enqueue(function(){b.push(1);return Q.resolve()});d.enqueue(function(){b.push(2);return Q.resolve()});d.enqueue(function(){var e=Q.defer();setTimeout(function(){b.push(3);e.resolve()},25);return e.promise},"foo");a=setTimeout(function(){d.abort().then(function(){expect(b).to.eql([1,2,3]);c()})},30)})});describe("scheduler",function(){it("should start remaining tasks when one ends",function(c){var d=new PThtroller(1,{foo:2});var b=0;d.enqueue(function(){b++;return Q.resolve()});d.enqueue(function(){b++;return Q.resolve()},"foo");d.enqueue(function(){b++;return Q.resolve()},"foo");d.enqueue(function(){b++;return Q.resolve()});d.enqueue(function(){b++;return Q.resolve()},"foo");a=setTimeout(function(){expect(b).to.equal(5);c()},25)});it("should respect the enqueue order",function(d){var e=new PThtroller(1);var c=[];var b=[];e.enqueue(function(){c.push(1);return Q.resolve()});e.enqueue(function(){c.push(2);return Q.resolve()});e.enqueue(function(){c.push(3);return Q.resolve()});e.enqueue(function(){b.push(1);return Q.resolve()},"foo");e.enqueue(function(){b.push(2);return Q.resolve()},"foo");e.enqueue(function(){b.push(3);return Q.resolve()},"foo");a=setTimeout(function(){expect(c).to.eql([1,2,3]);expect(b).to.eql([1,2,3]);d()},25)});it("should wait for one slot in every type on a multi-type function",function(c){var d=new PThtroller(1,{foo:1,bar:2});var b=0;d.enqueue(function(){return Q.defer().promise},"foo");d.enqueue(function(){return Q.defer().promise},"bar");d.enqueue(function(){b++;return Q.resolve()},"bar");d.enqueue(function(){c(new Error("Should not be called!"))},["foo","bar"]);d.enqueue(function(){b++;return Q.resolve()},"bar");d.enqueue(function(){c(new Error("Should not be called!"))},"foo");a=setTimeout(function(){expect(b).to.equal(2);c()},25)});it("should free all type slots when finished running a function",function(c){var d=new PThtroller(1,{foo:1,bar:2});var b=0;d.enqueue(function(){return Q.defer().promise},"bar");d.enqueue(function(){b++;return Q.resolve()},["foo","bar"]);d.enqueue(function(){b++;return Q.resolve()},"foo");d.enqueue(function(){b++;return Q.resolve()},"bar");a=setTimeout(function(){expect(b).to.equal(3);c()},25)})})});