var util=require("util");var path=require("path");var Q=require("q");var chmodr=require("chmodr");var rimraf=require("rimraf");var mkdirp=require("mkdirp");var which=require("which");var LRU=require("lru-cache");var mout=require("mout");var Resolver=require("./Resolver");var semver=require("../../util/semver");var createError=require("../../util/createError");var hasGit;try{which.sync("git");hasGit=true}catch(ex){hasGit=false}function GitResolver(c,b,a){mkdirp.sync(b.storage.empty);process.env.GIT_TEMPLATE_DIR=b.storage.empty;Resolver.call(this,c,b,a);if(!hasGit){throw createError("git is not installed or not in the PATH","ENOGIT")}}util.inherits(GitResolver,Resolver);mout.object.mixIn(GitResolver,Resolver);GitResolver.prototype._hasNew=function(b,c){var a=c._resolution||{};return this._findResolution().then(function(d){if(a.type!==d.type){return true}if(d.type==="version"&&semver.neq(d.tag,a.tag)){return true}return d.commit!==a.commit})};GitResolver.prototype._resolve=function(){var a=this;return this._findResolution().then(function(){return a._checkout().fin(function(){return a._cleanup()})})};GitResolver.prototype._checkout=function(){throw new Error("_checkout not implemented")};GitResolver.refs=function(a){throw new Error("refs not implemented")};GitResolver.prototype._findResolution=function(d){var c;var a=this.constructor;var b=this;d=d||this._target||"*";if((/^[a-f0-9]{40}$/).test(d)){this._resolution={type:"commit",commit:d};return Q.resolve(this._resolution)}if(semver.validRange(d)){return a.versions(this._source,true).then(function(e){var h,f,g;h=e.map(function(i){return i.version});if(!e.length&&d==="*"){return b._findResolution("master")}h=e.map(function(i){return i.version});g=semver.maxSatisfyingIndex(h,d,true);if(g!==-1){f=e[g];return b._resolution={type:"version",tag:f.tag,commit:f.commit}}return Q.all([a.branches(b._source),a.tags(b._source)]).spread(function(i,j){if(mout.object.hasOwn(j,d)){return b._resolution={type:"tag",tag:d,commit:j[d]}}if(mout.object.hasOwn(i,d)){return b._resolution={type:"branch",branch:d,commit:i[d]}}throw createError("No tag found that was able to satisfy "+d,"ENORESTARGET",{details:!e.length?"No versions found in "+b._source:"Available versions: "+e.map(function(k){return k.version}).join(", ")})})})}return Q.all([a.branches(b._source),a.tags(b._source)]).spread(function(e,f){if(mout.object.hasOwn(f,d)){return b._resolution={type:"tag",tag:d,commit:f[d]}}if(mout.object.hasOwn(e,d)){return b._resolution={type:"branch",branch:d,commit:e[d]}}if((/^[a-f0-9]{4,40}$/).test(d)){if(d.length<12){b._logger.warn("short-sha","Consider using longer commit SHA to avoid conflicts")}b._resolution={type:"commit",commit:d};return b._resolution}e=Object.keys(e);f=Object.keys(f);c=createError("Tag/branch "+d+" does not exist","ENORESTARGET");c.details=!f.length?"No tags found in "+b._source:"Available tags: "+f.join(", ");c.details+="\n";c.details+=!e.length?"No branches found in "+b._source:"Available branches: "+e.join(", ");throw c})};GitResolver.prototype._cleanup=function(){var a=path.join(this._tempDir,".git");if(process.platform==="win32"){return Q.nfcall(chmodr,a,511).then(function(){return Q.nfcall(rimraf,a)},function(b){if(b.code!=="ENOENT"){throw b}})}else{return Q.nfcall(rimraf,a)}};GitResolver.prototype._savePkgMeta=function(b){var a;if(this._resolution.type==="version"){a=semver.clean(this._resolution.tag);if(typeof b.version==="string"&&semver.neq(b.version,a)){this._logger.warn("mismatch","Version declared in the json ("+b.version+") is different than the resolved one ("+a+")",{resolution:this._resolution,pkgMeta:b})}b.version=a}else{delete b.version}b._release=a||this._resolution.tag||this._resolution.commit.substr(0,10);b._resolution=this._resolution;return Resolver.prototype._savePkgMeta.call(this,b)};GitResolver.versions=function(c,a){var b=this._cache.versions.get(c);if(b){return Q.resolve(b).then(function(){var d=this._cache.versions.get(c);if(!a){d=d.map(function(e){return e.version})}return d}.bind(this))}b=this.tags(c).then(function(g){var e;var f;var d=[];for(e in g){f=semver.clean(e);if(f){d.push({version:f,tag:e,commit:g[e]})}}d.sort(function(i,h){return semver.rcompare(i.version,h.version)});this._cache.versions.set(c,d);return this.versions(c,a)}.bind(this));this._cache.versions.set(c,b);return b};GitResolver.tags=function(b){var a=this._cache.tags.get(b);if(a){return Q.resolve(a)}a=this.refs(b).then(function(c){var d={};c.forEach(function(e){var f=e.match(/^([a-f0-9]{40})\s+refs\/tags\/(\S+)/);if(f&&!mout.string.endsWith(f[2],"^{}")){d[f[2]]=f[1]}});this._cache.tags.set(b,d);return d}.bind(this));this._cache.tags.set(b,a);return a};GitResolver.branches=function(b){var a=this._cache.branches.get(b);if(a){return Q.resolve(a)}a=this.refs(b).then(function(d){var c={};d.forEach(function(e){var f=e.match(/^([a-f0-9]{40})\s+refs\/heads\/(\S+)/);if(f){c[f[2]]=f[1]}});this._cache.branches.set(b,c);return c}.bind(this));this._cache.branches.set(b,a);return a};GitResolver.clearRuntimeCache=function(){mout.object.forOwn(GitResolver._cache,function(a){a.reset()})};GitResolver._cache={branches:new LRU({max:50,maxAge:5*60*1000}),tags:new LRU({max:50,maxAge:5*60*1000}),versions:new LRU({max:50,maxAge:5*60*1000}),refs:new LRU({max:50,maxAge:5*60*1000})};module.exports=GitResolver;